import imgviz
import numpy as np
import json
import os
from glob import glob
from PIL import Image
import cv2

def rotate_images_voc(path: str, angles: list):
    '''
    path - VOC Dataset root dir that generated by labelme2voc
    angles - degrees of image rotation
    '''
    def rotate_image_cv2(image, angle, flag):
        # https://stackoverflow.com/questions/9041681/opencv-python-rotate-image-by-x-degrees-around-specific-point
        
        image_center = tuple(np.array(image.shape[1::-1]) / 2)
        rot_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)
        result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=flag)
        return result
    
    label_root = os.path.join(path, 'SegmentationClassPNG')
    image_root = os.path.join(path, 'JPEGImages')

    label_processed_dir = os.path.join(label_root, 'processed')
    image_processed_dir = os.path.join(image_root, 'processed')

    if not os.path.exists(label_processed_dir):
        os.mkdir(label_processed_dir)
    if not os.path.exists(image_processed_dir):
        os.mkdir(image_processed_dir)

    labels = glob(os.path.join(label_root, '*.png'))
    images = glob(os.path.join(image_root, '*.jpg'))

    for path in labels:
        for a in angles:
            lbl = Image.open(path).convert("P")
            palette = lbl.getpalette()
            lbl = np.array(lbl)
            rotated_lbl = rotate_image_cv2(lbl, a, cv2.INTER_NEAREST)

            new_name = os.path.basename(path).split('.')
            new_name[0] = new_name[0] + '_' + str(a)
            new_name = '.'.join(new_name)

            rotated_lbl = Image.fromarray(rotated_lbl)
            rotated_lbl = rotated_lbl.convert("P")
            rotated_lbl.putpalette(palette)

            rotated_lbl.save(os.path.join(label_processed_dir, new_name))

    for path in images:
        for a in angles:
            img = cv2.imread(path)
            rotated_img = rotate_image_cv2(img, a, cv2.INTER_LINEAR)

            new_name = os.path.basename(path).split('.')
            new_name[0] = new_name[0] + '_' + str(a)
            new_name = '.'.join(new_name)

            cv2.imwrite(os.path.join(image_processed_dir, new_name), rotated_img)

def crop_image_voc(path: str, x1: float, y1: float, x2: float, y2: float):
    '''
    path - VOC Dataset root dir that generated by labelme2voc
    x1 - the cropping point of left top width from image
    y1 - the cropping point of left top height from image
    x2 - the cropping point of bottom right width from image
    y2 - the cropping point of bottom right height from image
    '''
    processed_dir = os.path.join(path, 'processed')
    filenames = glob(os.path.join(path, 'SegmentationClassPNG', '*.png'))
    filenames.extend(glob(os.path.join(path, 'JPEGImages', '*.jpg')))
    img = None

    if not os.path.exists(processed_dir):
        os.mkdir(processed_dir)

    for filename in filenames:
        category = os.path.split(os.path.split(filename)[0])[-1]
        if not os.path.exists(os.path.join(processed_dir, category)):
            os.mkdir(os.path.join(processed_dir, category))

        img = Image.open(filename)
        img = img.crop((x1, y1, x2, y2))
        img.save(os.path.join(os.path.join(processed_dir, category), os.path.basename(filename)))

def crop_process_labelme(path: str, x1: float, y1: float, x2: float, y2: float):
    '''
    path - Directory that contains labelme JSONs
    x1 - the cropping point of left top width from image
    y1 - the cropping point of left top height from image
    x2 - the cropping point of bottom right width from image
    y2 - the cropping point of bottom right height from image
    '''
    
    processed_dir = os.path.join(path, 'processed')
    paths = glob(os.path.join(path, '*.json'))

    if not os.path.exists(processed_dir):
        os.mkdir(processed_dir)

    for path in paths:
        with open(path, 'r') as f:
            print('Processing : ', os.path.basename(path))
            tmp = json.load(f)
            i = 0

            while True:
                try:
                    shape = tmp['shapes'][i]
                    min_x = tmp['imageWidth'] + 1
                    max_x = -1
                    min_y = tmp['imageHeight'] + 1
                    max_y = -1

                    points = shape['points']
                    for point in points:
                        min_x = min(point[0], min_x)
                        max_x = max(point[0], max_x)
                        min_y = min(point[1], min_y)
                        max_y = max(point[1], max_y)

                    left = (x1 - max_x) > 0
                    right = (x2 - min_x) > 0
                    top = (y1 - max_y) > 0
                    bottom = (y2 - min_y) > 0

                    if top:
                        # if every points of a shape is out of cutting range,
                        # then it will not appear in a cropped picture. we don't need this.

                        print(tmp['shapes'][i]['label'], max_x, min_x, max_y, min_y)
                        del tmp['shapes'][i]
                    else:
                        print('Cliping : ', i)
                        for point in points:
                            # Clipping points
                            if int(point[0]) >= x2:
                                point[0] = x2
                            if int(point[1]) >= y2:
                                point[1] = y2
                            if int(point[0]) <= x1:
                                point[0] = x1
                            if int(point[1]) <= y1:
                                point[1] = y1
                        i += 1
                except IndexError:
                    break
        with open(os.path.join(processed_dir, os.path.basename(path)), 'w') as f:
            json.dump(tmp, f, indent=2)
